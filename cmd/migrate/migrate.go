package main

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"

	"github.com/williamokano/pg_backuper/pkg/backuper"
	"github.com/williamokano/pg_backuper/pkg/config"
)

// OldConfig represents the v1 configuration format
type OldConfig = backuper.Config

func main() {
	if len(os.Args) < 3 {
		fmt.Fprintf(os.Stderr, "Usage: migrate <old-config.json> <output-directory>\n")
		fmt.Fprintf(os.Stderr, "\nExample:\n")
		fmt.Fprintf(os.Stderr, "  migrate old_config.json /path/to/backup-config/\n")
		fmt.Fprintf(os.Stderr, "\nThis will create:\n")
		fmt.Fprintf(os.Stderr, "  /path/to/backup-config/config.json\n")
		fmt.Fprintf(os.Stderr, "  /path/to/backup-config/.pgpass\n")
		os.Exit(1)
	}

	oldConfigPath := os.Args[1]
	outputDir := os.Args[2]

	fmt.Printf("Migrating configuration from v1 to v2...\n")
	fmt.Printf("  Input: %s\n", oldConfigPath)
	fmt.Printf("  Output directory: %s\n", outputDir)

	// Read old config
	fmt.Printf("\nReading old configuration...\n")
	oldConfig, err := backuper.ParseConfig(oldConfigPath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error reading old config: %v\n", err)
		os.Exit(1)
	}

	// Create output directory
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		fmt.Fprintf(os.Stderr, "Error creating output directory: %v\n", err)
		os.Exit(1)
	}

	// Convert to new config
	fmt.Printf("Converting to new format...\n")
	newConfig := convertConfig(oldConfig)

	// Write new config file
	newConfigPath := filepath.Join(outputDir, "config.json")
	fmt.Printf("Writing new config to: %s\n", newConfigPath)
	if err := writeConfig(newConfig, newConfigPath); err != nil {
		fmt.Fprintf(os.Stderr, "Error writing new config: %v\n", err)
		os.Exit(1)
	}

	// Write .pgpass file
	pgpassPath := filepath.Join(outputDir, ".pgpass")
	fmt.Printf("Writing .pgpass file to: %s\n", pgpassPath)
	if err := writePgpass(oldConfig, pgpassPath); err != nil {
		fmt.Fprintf(os.Stderr, "Error writing .pgpass file: %v\n", err)
		os.Exit(1)
	}

	// Set correct permissions on .pgpass
	if err := os.Chmod(pgpassPath, 0600); err != nil {
		fmt.Fprintf(os.Stderr, "Error setting .pgpass permissions: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("\nâœ“ Migration complete!\n")
	fmt.Printf("\nNext steps:\n")
	fmt.Printf("1. Review the generated files:\n")
	fmt.Printf("     config: %s\n", newConfigPath)
	fmt.Printf("     pgpass: %s\n", pgpassPath)
	fmt.Printf("2. Update your Docker/Portainer volume mapping to mount: %s:/config\n", outputDir)
	fmt.Printf("3. Set environment variable: CONFIG_FILE=/config/config.json\n")
	fmt.Printf("4. Test with: pg_backuper --config %s\n", newConfigPath)
}

func convertConfig(old *backuper.Config) *config.Config {
	newConfig := &config.Config{
		BackupDir: old.BackupDir,
		GlobalDefaults: config.GlobalDefaults{
			Port: 5432, // Default PostgreSQL port
			RetentionTiers: []config.RetentionTier{
				{
					Tier:      "daily",
					Retention: old.Retention,
				},
			},
			PgpassFile: "/config/.pgpass", // Default for Docker/Portainer
		},
		MaxConcurrentBackups: 3,      // Default
		LogLevel:             "info",  // Default
		LogFormat:            "json",  // Default
		Databases:            make([]config.DatabaseConfig, 0, len(old.Databases)),
	}

	// Convert databases
	for _, oldDB := range old.Databases {
		newDB := config.DatabaseConfig{
			Name:    oldDB.Name,
			User:    oldDB.User,
			Host:    oldDB.Host,
			Enabled: true, // Default to enabled
		}
		newConfig.Databases = append(newConfig.Databases, newDB)
	}

	return newConfig
}

func writeConfig(cfg *config.Config, path string) error {
	file, err := os.Create(path)
	if err != nil {
		return fmt.Errorf("failed to create config file: %w", err)
	}
	defer file.Close()

	encoder := json.NewEncoder(file)
	encoder.SetIndent("", "  ")
	if err := encoder.Encode(cfg); err != nil {
		return fmt.Errorf("failed to encode config: %w", err)
	}

	return nil
}

func writePgpass(old *backuper.Config, path string) error {
	file, err := os.Create(path)
	if err != nil {
		return fmt.Errorf("failed to create .pgpass file: %w", err)
	}
	defer file.Close()

	// Write header comment
	fmt.Fprintf(file, "# PostgreSQL password file\n")
	fmt.Fprintf(file, "# Format: hostname:port:database:username:password\n")
	fmt.Fprintf(file, "# Generated by pg_backuper migration tool\n\n")

	// Write entries for each database
	for _, db := range old.Databases {
		// Format: hostname:port:database:username:password
		// Use * for database to allow any database name
		fmt.Fprintf(file, "%s:5432:*:%s:%s\n", db.Host, db.User, db.Password)
	}

	return nil
}
